{"ast":null,"code":"import { OAuthErrorEvent } from 'angular-oauth2-oidc';\nimport { BehaviorSubject, combineLatest } from 'rxjs';\nimport { filter, map } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"angular-oauth2-oidc\";\nimport * as i2 from \"@angular/router\";\nexport class AuthService {\n  navigateToLoginPage() {\n    // TODO: Remember current URL\n    this.router.navigateByUrl('/should-login');\n  }\n  constructor(oauthService, router) {\n    this.oauthService = oauthService;\n    this.router = router;\n    this.isAuthenticatedSubject$ = new BehaviorSubject(false);\n    this.isAuthenticated$ = this.isAuthenticatedSubject$.asObservable();\n    this.isDoneLoadingSubject$ = new BehaviorSubject(false);\n    this.isDoneLoading$ = this.isDoneLoadingSubject$.asObservable();\n    /**\r\n     * Publishes `true` if and only if (a) all the asynchronous initial\r\n     * login calls have completed or errorred, and (b) the user ended up\r\n     * being authenticated.\r\n     *\r\n     * In essence, it combines:\r\n     *\r\n     * - the latest known state of whether the user is authorized\r\n     * - whether the ajax calls for initial log in have all been done\r\n     */\n    this.canActivateProtectedRoutes$ = combineLatest([this.isAuthenticated$, this.isDoneLoading$]).pipe(map(values => values.every(b => b)));\n    // Useful for debugging:\n    this.oauthService.events.subscribe(event => {\n      if (event instanceof OAuthErrorEvent) {\n        console.error('OAuthErrorEvent Object:', event);\n      } else {\n        console.warn('OAuthEvent Object:', event);\n      }\n    });\n    // This is tricky, as it might cause race conditions (where access_token is set in another\n    // tab before everything is said and done there.\n    // TODO: Improve this setup. See: https://github.com/jeroenheijmans/sample-angular-oauth2-oidc-with-auth-guards/issues/2\n    window.addEventListener('storage', event => {\n      // The `key` is `null` if the event was caused by `.clear()`\n      if (event.key !== 'access_token' && event.key !== null) {\n        return;\n      }\n      console.warn('Noticed changes to access_token (most likely from another tab), updating isAuthenticated');\n      this.isAuthenticatedSubject$.next(this.oauthService.hasValidAccessToken());\n      if (!this.oauthService.hasValidAccessToken()) {\n        this.navigateToLoginPage();\n      }\n    });\n    this.oauthService.events.subscribe(_ => {\n      this.isAuthenticatedSubject$.next(this.oauthService.hasValidAccessToken());\n    });\n    this.isAuthenticatedSubject$.next(this.oauthService.hasValidAccessToken());\n    this.oauthService.events.pipe(filter(e => ['token_received'].includes(e.type))).subscribe(e => this.oauthService.loadUserProfile());\n    this.oauthService.events.pipe(filter(e => ['session_terminated', 'session_error'].includes(e.type))).subscribe(e => this.navigateToLoginPage());\n    this.oauthService.setupAutomaticSilentRefresh();\n  }\n  runInitialLoginSequence() {\n    if (location.hash) {\n      console.log('Encountered hash fragment, plotting as table...');\n      console.table(location.hash.substr(1).split('&').map(kvp => kvp.split('=')));\n    }\n    // 0. LOAD CONFIG:\n    // First we have to check to see how the IdServer is\n    // currently configured:\n    return this.oauthService.loadDiscoveryDocument()\n    // For demo purposes, we pretend the previous call was very slow\n    .then(() => new Promise(resolve => setTimeout(() => resolve(), 1500)))\n    // 1. HASH LOGIN:\n    // Try to log in via hash fragment after redirect back\n    // from IdServer from initImplicitFlow:\n    .then(() => this.oauthService.tryLogin()).then(() => {\n      if (this.oauthService.hasValidAccessToken()) {\n        return Promise.resolve();\n      }\n      // 2. SILENT LOGIN:\n      // Try to log in via a refresh because then we can prevent\n      // needing to redirect the user:\n      return this.oauthService.silentRefresh().then(() => Promise.resolve()).catch(result => {\n        // Subset of situations from https://openid.net/specs/openid-connect-core-1_0.html#AuthError\n        // Only the ones where it's reasonably sure that sending the\n        // user to the IdServer will help.\n        const errorResponsesRequiringUserInteraction = ['interaction_required', 'login_required', 'account_selection_required', 'consent_required'];\n        if (result && result.reason && errorResponsesRequiringUserInteraction.indexOf(result.reason.error) >= 0) {\n          // 3. ASK FOR LOGIN:\n          // At this point we know for sure that we have to ask the\n          // user to log in, so we redirect them to the IdServer to\n          // enter credentials.\n          //\n          // Enable this to ALWAYS force a user to login.\n          // this.login();\n          //\n          // Instead, we'll now do this:\n          console.warn('User interaction is needed to log in, we will wait for the user to manually log in.');\n          return Promise.resolve();\n        }\n        // We can't handle the truth, just pass on the problem to the\n        // next handler.\n        return Promise.reject(result);\n      });\n    }).then(() => {\n      this.isDoneLoadingSubject$.next(true);\n      // Check for the strings 'undefined' and 'null' just to be sure. Our current\n      // login(...) should never have this, but in case someone ever calls\n      // initImplicitFlow(undefined | null) this could happen.\n      if (this.oauthService.state && this.oauthService.state !== 'undefined' && this.oauthService.state !== 'null') {\n        let stateUrl = this.oauthService.state;\n        if (stateUrl.startsWith('/') === false) {\n          stateUrl = decodeURIComponent(stateUrl);\n        }\n        console.log(`There was state of ${this.oauthService.state}, so we are sending you to: ${stateUrl}`);\n        this.router.navigateByUrl(stateUrl);\n      }\n    }).catch(() => this.isDoneLoadingSubject$.next(true));\n  }\n  login(targetUrl) {\n    // Note: before version 9.1.0 of the library you needed to\n    // call encodeURIComponent on the argument to the method.\n    debugger;\n    this.oauthService.initLoginFlow(targetUrl || this.router.url);\n  }\n  logout() {\n    this.oauthService.logOut();\n  }\n  refresh() {\n    this.oauthService.silentRefresh();\n  }\n  hasValidToken() {\n    return this.oauthService.hasValidAccessToken();\n  }\n  // These normally won't be exposed from a service like this, but\n  // for debugging it makes sense.\n  get accessToken() {\n    return this.oauthService.getAccessToken();\n  }\n  get refreshToken() {\n    return this.oauthService.getRefreshToken();\n  }\n  get identityClaims() {\n    return this.oauthService.getIdentityClaims();\n  }\n  get idToken() {\n    return this.oauthService.getIdToken();\n  }\n  get logoutUrl() {\n    return this.oauthService.logoutUrl;\n  }\n}\nAuthService.ɵfac = function AuthService_Factory(t) {\n  return new (t || AuthService)(i0.ɵɵinject(i1.OAuthService), i0.ɵɵinject(i2.Router));\n};\nAuthService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: AuthService,\n  factory: AuthService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":"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","names":["OAuthErrorEvent","BehaviorSubject","combineLatest","filter","map","AuthService","navigateToLoginPage","router","navigateByUrl","constructor","oauthService","isAuthenticatedSubject$","asObservable","isDoneLoadingSubject$","isAuthenticated$","isDoneLoading$","pipe","values","every","b","events","subscribe","event","console","error","warn","window","addEventListener","key","next","hasValidAccessToken","_","e","includes","type","loadUserProfile","setupAutomaticSilentRefresh","runInitialLoginSequence","location","hash","log","table","substr","split","kvp","loadDiscoveryDocument","then","Promise","resolve","setTimeout","tryLogin","silentRefresh","catch","result","errorResponsesRequiringUserInteraction","reason","indexOf","reject","state","stateUrl","startsWith","decodeURIComponent","login","targetUrl","initLoginFlow","url","logout","logOut","refresh","hasValidToken","accessToken","getAccessToken","refreshToken","getRefreshToken","identityClaims","getIdentityClaims","idToken","getIdToken","logoutUrl","factory","providedIn"],"sourceRoot":"","sources":["D:\\Projekte\\samples\\angular-client-keycloak\\client\\src\\app\\core\\auth.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { Router } from '@angular/router';\nimport { OAuthErrorEvent, OAuthService } from 'angular-oauth2-oidc';\nimport { BehaviorSubject, combineLatest, Observable } from 'rxjs';\nimport { filter, map } from 'rxjs/operators';\n\n\n@Injectable({ providedIn: 'root' })\nexport class AuthService {\n\n  private isAuthenticatedSubject$ = new BehaviorSubject<boolean>(false);\n  public isAuthenticated$ = this.isAuthenticatedSubject$.asObservable();\n\n  private isDoneLoadingSubject$ = new BehaviorSubject<boolean>(false);\n  public isDoneLoading$ = this.isDoneLoadingSubject$.asObservable();\n\n  /**\n   * Publishes `true` if and only if (a) all the asynchronous initial\n   * login calls have completed or errorred, and (b) the user ended up\n   * being authenticated.\n   *\n   * In essence, it combines:\n   *\n   * - the latest known state of whether the user is authorized\n   * - whether the ajax calls for initial log in have all been done\n   */\n  public canActivateProtectedRoutes$: Observable<boolean> = combineLatest([\n    this.isAuthenticated$,\n    this.isDoneLoading$\n  ]).pipe(map(values => values.every(b => b)));\n\n  private navigateToLoginPage() {\n    // TODO: Remember current URL\n    this.router.navigateByUrl('/should-login');\n  }\n\n  constructor(\n    private oauthService: OAuthService,\n    private router: Router,\n  ) {\n    // Useful for debugging:\n    this.oauthService.events.subscribe(event => {\n      if (event instanceof OAuthErrorEvent) {\n        console.error('OAuthErrorEvent Object:', event);\n      } else {\n        console.warn('OAuthEvent Object:', event);\n      }\n    });\n\n    // This is tricky, as it might cause race conditions (where access_token is set in another\n    // tab before everything is said and done there.\n    // TODO: Improve this setup. See: https://github.com/jeroenheijmans/sample-angular-oauth2-oidc-with-auth-guards/issues/2\n    window.addEventListener('storage', (event) => {\n      // The `key` is `null` if the event was caused by `.clear()`\n      if (event.key !== 'access_token' && event.key !== null) {\n        return;\n      }\n\n      console.warn('Noticed changes to access_token (most likely from another tab), updating isAuthenticated');\n      this.isAuthenticatedSubject$.next(this.oauthService.hasValidAccessToken());\n\n      if (!this.oauthService.hasValidAccessToken()) {\n        this.navigateToLoginPage();\n      }\n    });\n\n    this.oauthService.events\n      .subscribe(_ => {\n        this.isAuthenticatedSubject$.next(this.oauthService.hasValidAccessToken());\n      });\n    this.isAuthenticatedSubject$.next(this.oauthService.hasValidAccessToken());\n\n    this.oauthService.events\n      .pipe(filter(e => ['token_received'].includes(e.type)))\n      .subscribe(e => this.oauthService.loadUserProfile());\n\n    this.oauthService.events\n      .pipe(filter(e => ['session_terminated', 'session_error'].includes(e.type)))\n      .subscribe(e => this.navigateToLoginPage());\n\n    this.oauthService.setupAutomaticSilentRefresh();\n  }\n\n  public runInitialLoginSequence(): Promise<void> {\n    if (location.hash) {\n      console.log('Encountered hash fragment, plotting as table...');\n      console.table(location.hash.substr(1).split('&').map(kvp => kvp.split('=')));\n    }\n\n    // 0. LOAD CONFIG:\n    // First we have to check to see how the IdServer is\n    // currently configured:\n    return this.oauthService.loadDiscoveryDocument()\n\n      // For demo purposes, we pretend the previous call was very slow\n      .then(() => new Promise<void>(resolve => setTimeout(() => resolve(), 1500)))\n\n      // 1. HASH LOGIN:\n      // Try to log in via hash fragment after redirect back\n      // from IdServer from initImplicitFlow:\n      .then(() => this.oauthService.tryLogin())\n\n      .then(() => {\n        if (this.oauthService.hasValidAccessToken()) {\n          return Promise.resolve();\n        }\n\n        // 2. SILENT LOGIN:\n        // Try to log in via a refresh because then we can prevent\n        // needing to redirect the user:\n        return this.oauthService.silentRefresh()\n          .then(() => Promise.resolve())\n          .catch(result => {\n            // Subset of situations from https://openid.net/specs/openid-connect-core-1_0.html#AuthError\n            // Only the ones where it's reasonably sure that sending the\n            // user to the IdServer will help.\n            const errorResponsesRequiringUserInteraction = [\n              'interaction_required',\n              'login_required',\n              'account_selection_required',\n              'consent_required',\n            ];\n\n            if (result\n              && result.reason\n              && errorResponsesRequiringUserInteraction.indexOf(result.reason.error) >= 0) {\n\n              // 3. ASK FOR LOGIN:\n              // At this point we know for sure that we have to ask the\n              // user to log in, so we redirect them to the IdServer to\n              // enter credentials.\n              //\n              // Enable this to ALWAYS force a user to login.\n              // this.login();\n              //\n              // Instead, we'll now do this:\n              console.warn('User interaction is needed to log in, we will wait for the user to manually log in.');\n              return Promise.resolve();\n            }\n\n            // We can't handle the truth, just pass on the problem to the\n            // next handler.\n            return Promise.reject(result);\n          });\n      })\n\n      .then(() => {\n        this.isDoneLoadingSubject$.next(true);\n\n        // Check for the strings 'undefined' and 'null' just to be sure. Our current\n        // login(...) should never have this, but in case someone ever calls\n        // initImplicitFlow(undefined | null) this could happen.\n        if (this.oauthService.state && this.oauthService.state !== 'undefined' && this.oauthService.state !== 'null') {\n          let stateUrl = this.oauthService.state;\n          if (stateUrl.startsWith('/') === false) {\n            stateUrl = decodeURIComponent(stateUrl);\n          }\n          console.log(`There was state of ${this.oauthService.state}, so we are sending you to: ${stateUrl}`);\n          this.router.navigateByUrl(stateUrl);\n        }\n      })\n      .catch(() => this.isDoneLoadingSubject$.next(true));\n  }\n\n  public login(targetUrl?: string) {\n    // Note: before version 9.1.0 of the library you needed to\n    // call encodeURIComponent on the argument to the method.\n    debugger;\n    this.oauthService.initLoginFlow(targetUrl || this.router.url);\n  }\n\n  public logout() { this.oauthService.logOut(); }\n  public refresh() { this.oauthService.silentRefresh(); }\n  public hasValidToken() { return this.oauthService.hasValidAccessToken(); }\n\n  // These normally won't be exposed from a service like this, but\n  // for debugging it makes sense.\n  public get accessToken() { return this.oauthService.getAccessToken(); }\n  public get refreshToken() { return this.oauthService.getRefreshToken(); }\n  public get identityClaims() { return this.oauthService.getIdentityClaims(); }\n  public get idToken() { return this.oauthService.getIdToken(); }\n  public get logoutUrl() { return this.oauthService.logoutUrl; }\n}\n\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}