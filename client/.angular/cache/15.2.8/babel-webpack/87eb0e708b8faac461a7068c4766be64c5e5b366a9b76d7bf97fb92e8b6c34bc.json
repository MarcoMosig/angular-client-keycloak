{"ast":null,"code":"import { OAuthErrorEvent } from 'angular-oauth2-oidc';\nimport { BehaviorSubject, combineLatest } from 'rxjs';\nimport { filter, map } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"angular-oauth2-oidc\";\nimport * as i2 from \"@angular/router\";\nexport let AuthService = /*#__PURE__*/(() => {\n  class AuthService {\n    navigateToLoginPage() {\n      // TODO: Remember current URL\n      this.router.navigateByUrl('/should-login');\n    }\n    constructor(oauthService, router) {\n      this.oauthService = oauthService;\n      this.router = router;\n      this.isAuthenticatedSubject$ = new BehaviorSubject(false);\n      this.isAuthenticated$ = this.isAuthenticatedSubject$.asObservable();\n      this.isDoneLoadingSubject$ = new BehaviorSubject(false);\n      this.isDoneLoading$ = this.isDoneLoadingSubject$.asObservable();\n      /**\r\n       * Publishes `true` if and only if (a) all the asynchronous initial\r\n       * login calls have completed or errorred, and (b) the user ended up\r\n       * being authenticated.\r\n       *\r\n       * In essence, it combines:\r\n       *\r\n       * - the latest known state of whether the user is authorized\r\n       * - whether the ajax calls for initial log in have all been done\r\n       */\n      this.canActivateProtectedRoutes$ = combineLatest([this.isAuthenticated$, this.isDoneLoading$]).pipe(map(values => values.every(b => b)));\n      // Useful for debugging:\n      this.oauthService.events.subscribe(event => {\n        if (event instanceof OAuthErrorEvent) {\n          console.error('OAuthErrorEvent Object:', event);\n        } else {\n          console.warn('OAuthEvent Object:', event);\n        }\n      });\n      // This is tricky, as it might cause race conditions (where access_token is set in another\n      // tab before everything is said and done there.\n      // TODO: Improve this setup. See: https://github.com/jeroenheijmans/sample-angular-oauth2-oidc-with-auth-guards/issues/2\n      window.addEventListener('storage', event => {\n        // The `key` is `null` if the event was caused by `.clear()`\n        if (event.key !== 'access_token' && event.key !== null) {\n          return;\n        }\n        console.warn('Noticed changes to access_token (most likely from another tab), updating isAuthenticated');\n        this.isAuthenticatedSubject$.next(this.oauthService.hasValidAccessToken());\n        if (!this.oauthService.hasValidAccessToken()) {\n          this.navigateToLoginPage();\n        }\n      });\n      this.oauthService.events.subscribe(_ => {\n        this.isAuthenticatedSubject$.next(this.oauthService.hasValidAccessToken());\n      });\n      this.isAuthenticatedSubject$.next(this.oauthService.hasValidAccessToken());\n      this.oauthService.events.pipe(filter(e => ['token_received'].includes(e.type))).subscribe(e => this.oauthService.loadUserProfile());\n      this.oauthService.events.pipe(filter(e => ['session_terminated', 'session_error'].includes(e.type))).subscribe(e => this.navigateToLoginPage());\n      this.oauthService.setupAutomaticSilentRefresh();\n    }\n    runInitialLoginSequence() {\n      if (location.hash) {\n        console.log('Encountered hash fragment, plotting as table...');\n        console.table(location.hash.substr(1).split('&').map(kvp => kvp.split('=')));\n      }\n      // 0. LOAD CONFIG:\n      // First we have to check to see how the IdServer is\n      // currently configured:\n      return this.oauthService.loadDiscoveryDocument()\n      // For demo purposes, we pretend the previous call was very slow\n      .then(() => new Promise(resolve => setTimeout(() => resolve(), 1500)))\n      // 1. HASH LOGIN:\n      // Try to log in via hash fragment after redirect back\n      // from IdServer from initImplicitFlow:\n      .then(() => this.oauthService.tryLogin()).then(() => {\n        if (this.oauthService.hasValidAccessToken()) {\n          return Promise.resolve();\n        }\n        // 2. SILENT LOGIN:\n        // Try to log in via a refresh because then we can prevent\n        // needing to redirect the user:\n        return this.oauthService.silentRefresh().then(() => Promise.resolve()).catch(result => {\n          // Subset of situations from https://openid.net/specs/openid-connect-core-1_0.html#AuthError\n          // Only the ones where it's reasonably sure that sending the\n          // user to the IdServer will help.\n          const errorResponsesRequiringUserInteraction = ['interaction_required', 'login_required', 'account_selection_required', 'consent_required'];\n          if (result && result.reason && errorResponsesRequiringUserInteraction.indexOf(result.reason.error) >= 0) {\n            // 3. ASK FOR LOGIN:\n            // At this point we know for sure that we have to ask the\n            // user to log in, so we redirect them to the IdServer to\n            // enter credentials.\n            //\n            // Enable this to ALWAYS force a user to login.\n            // this.login();\n            //\n            // Instead, we'll now do this:\n            console.warn('User interaction is needed to log in, we will wait for the user to manually log in.');\n            return Promise.resolve();\n          }\n          // We can't handle the truth, just pass on the problem to the\n          // next handler.\n          return Promise.reject(result);\n        });\n      }).then(() => {\n        this.isDoneLoadingSubject$.next(true);\n        // Check for the strings 'undefined' and 'null' just to be sure. Our current\n        // login(...) should never have this, but in case someone ever calls\n        // initImplicitFlow(undefined | null) this could happen.\n        if (this.oauthService.state && this.oauthService.state !== 'undefined' && this.oauthService.state !== 'null') {\n          let stateUrl = this.oauthService.state;\n          if (stateUrl.startsWith('/') === false) {\n            stateUrl = decodeURIComponent(stateUrl);\n          }\n          console.log(`There was state of ${this.oauthService.state}, so we are sending you to: ${stateUrl}`);\n          this.router.navigateByUrl(stateUrl);\n        }\n      }).catch(() => this.isDoneLoadingSubject$.next(true));\n    }\n    login(targetUrl) {\n      // Note: before version 9.1.0 of the library you needed to\n      // call encodeURIComponent on the argument to the method.\n      this.oauthService.initLoginFlow(targetUrl || this.router.url);\n    }\n    logout() {\n      this.oauthService.logOut();\n    }\n    refresh() {\n      this.oauthService.silentRefresh();\n    }\n    hasValidToken() {\n      return this.oauthService.hasValidAccessToken();\n    }\n    // These normally won't be exposed from a service like this, but\n    // for debugging it makes sense.\n    get accessToken() {\n      return this.oauthService.getAccessToken();\n    }\n    get refreshToken() {\n      return this.oauthService.getRefreshToken();\n    }\n    get identityClaims() {\n      return this.oauthService.getIdentityClaims();\n    }\n    get idToken() {\n      return this.oauthService.getIdToken();\n    }\n    get logoutUrl() {\n      return this.oauthService.logoutUrl;\n    }\n  }\n  AuthService.ɵfac = function AuthService_Factory(t) {\n    return new (t || AuthService)(i0.ɵɵinject(i1.OAuthService), i0.ɵɵinject(i2.Router));\n  };\n  AuthService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: AuthService,\n    factory: AuthService.ɵfac,\n    providedIn: 'root'\n  });\n  return AuthService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}